#version 430 core

layout(location = 0) uniform uint uFaces;
layout(location = 1) uniform uint uEdges;
layout(location = 2) uniform uint uVertices;

layout(std430, binding = 0) buffer VertexBuffer {
	vec3 vertexPosition[];
};

layout(std430, binding = 1) buffer AdjacencyBuffer {
	uint adjacency[];
};

layout(std430, binding = 2) buffer AdjacencyIndicesBuffer {
	uint adjacencyIndices[];
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main() {
	uint workIndex = gl_WorkGroupID.x * 8 + gl_WorkGroupID.y;

	if (workIndex < uVertices) {
		workIndex += uFaces + uEdges;
		uint adjacencyIndex = adjacencyIndices[workIndex];
		uint vertexIndex = adjacency[adjacencyIndex];
		uint valence = adjacency[adjacencyIndex + 1];
		float fvalence = valence;

		uint vertIdx = adjacencyIndex + 2;
		vec3 edges = vec3(0.0);
		vec3 faces = vec3(0.0);

		for (uint vert = 0; vert < valence; vert++) {
			edges += vertexPosition[adjacency[vertIdx++]];
		}

		edges /= fvalence;

		if (valence > 2) {
			for (uint vert = 0; vert < valence; vert++) {
				faces += vertexPosition[adjacency[vertIdx++]];
			}

			faces /= fvalence;

			vec3 pos = (fvalence - 2.0) * vertexPosition[adjacency[vertIdx]];

			vertexPosition[vertexIndex] = (pos + edges + faces) / fvalence;
		} else if (valence == 2) {
			// Boundary
			vec3 pos = (3.0) * vertexPosition[adjacency[vertIdx]];

			vertexPosition[vertexIndex] = (pos + edges) / 4.0;
		}
	}
}
